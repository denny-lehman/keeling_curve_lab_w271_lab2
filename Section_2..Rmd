---
title: 'Statistical Methods for Discrete Response, Time Series, and Panel Data (W271): Lab 2'
subtitle: "Investigating the Keeling Curve and forecasting CO2 levels in Earth's atmosphere"

# classoption: landscape
fontsize: 11pt
geometry: margin=1in
output: 
  pdf_document:
    toc: true
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## SECTION 2 
## Report from the Point of View of the Present 
One of the very interesting features of Keeling and colleagues' research is that they were able to evaluate, and re-evaluate the data as new series of measurements were released. This permitted the evaluation of previous models' performance and a much more difficult question: If their models' predictions were "off" was this the result of a failure of the model, or a change in the system? 

## (1 point) Task 0b: Introduction 
In this introduction, you can assume that your reader will have **just** read your 1997 report. In this introduction, **very** briefly pose the question that you are evaluating, and describe what (if anything) has changed in the data generating process between 1997 and the present.

```{r include=FALSE}
current_directory <- getwd()
print(current_directory)

```

```{r include=FALSE}
co2_new <- read.table("co2_weekly_mlo.csv", sep = ",", header = TRUE)
co2_new

```

```{r include=FALSE }

install.packages("tsibble")
install.packages("fable")
install.packages("gridExtra")
install.packages("magrittr")
install.packages("ggseas")

```

```{r include=FALSE}
# Load the magrittr package
library(tidyverse)
library(tsibble)
library(fable)
library(ggplot2)
library(gridExtra)

library(magrittr)
library(dplyr)
# library(ggseas)
library(forecast)
library(tsibble)
library(stats)
library(ggseas)
library(fable)
library(fabletools)
# has_gaps(co2_new)
library(stats)
library(lubridate)
```

### (3 points) Task 1b: Create a modern data pipeline for Mona Loa CO2 data. [Weekly Data] [ EDA - ACF, PACF, Seasonality, decomposition]
The most current data is provided by the United States' National Oceanic and Atmospheric Administration, on a data page [[here](https://gml.noaa.gov/ccgg/trends/data.html)]. Gather the most recent weekly data from this page. (A group that is interested in even more data management might choose to work with the [hourly data](https://gml.noaa.gov/aftp/data/trace_gases/co2/in-situ/surface/mlo/co2_mlo_surface-insitu_1_ccgg_HourlyData.txt).) 
Create a data pipeline that starts by reading from the appropriate URL, and ends by saving an object called `co2_present` that is a suitable time series object. 
Conduct the same EDA on this data. Describe how the Keeling Curve evolved from 1997 to the present, noting where the series seems to be following similar trends to the series that you "evaluated in 1997" and where the series seems to be following different trends. This EDA can use the same, or very similar tools and views as you provided in your 1997 report. 


```{r include=FALSE}
# Data Pipeline 

co2_present <- read.table("co2_weekly_mlo.csv", sep = ",", header = TRUE)

co2_present <- co2_new %>%
  mutate(date = paste(year, month, day, sep = "-")) %>%
  mutate(index = as.Date(date)) %>%
  filter(year(date) >= 1997, average > 0) %>%
  as_tsibble(index = index)

co2_present

```


```{r , echo = FALSE, ,fig.height=3}
# EDA - Checking for non-stationary time series
# ** changing mean and varying variance so seem like non stationary**

co2_new_p25 <- co2_present %>%
  ggplot(aes(x = index, y = average)) + 
  geom_line() + 
  labs(title = "checking for non-stationarity" , subtitle = "co2 level" , y = "CO2 Values" , x = "Time")

co2_new_p25
```

```{r include=FALSE}
# Extracting Week  from the index column (which is Date)
# Viewing the seasonality

co2_present <- co2_present %>%
  mutate(week = yearweek(index)) %>%
  as_tsibble(index = week)

co2_present
```


```{r include=FALSE}
co2_present <- tsibble::fill_gaps(co2_present)
```

```{r  , echo = FALSE, ,fig.height=3}
library(feasts)

co2_present <- tsibble::fill_gaps(co2_present)

p27 <- co2_present%>%gg_season(average , labels = "both") + 
  labs(y = "Values" , x = "Time" , title = "Seasonality")
p27
```


```{r , echo = FALSE , fig.height=3}
library(feasts)

# ** CO2 level is increasing with year and reaching 425 in 2023**

p27 <- co2_present%>%gg_season(average , labels = "both") + 
  labs(y = "Values" , x = "Time" , title = "Seasonality")
p27
```




```{r , echo = FALSE , fig.height=3}

library(feasts)
library(gridExtra)

p28 <- co2_present%>%gg_subseries (average) + 
  labs(y = "average" , x = "Time" , title = "Seasonality")

p28

grid.arrange(p27, p28, nrow = 2, ncol = 1)

```

```{r , echo = FALSE , fig.height=3 }
# # EDA -  checking ACF plots if they have trend or seasonality
# ** Gradual trend in ACF model seems like a ARIMA model and strong correlation among all lags from 1 to 12 so seems # like ARIMA model **
  
library(gridExtra)

p29 <- co2_present %>% gg_lag(average, geom = "point" , lag = 1:12) + 
  labs(title = "lagged Scatterplot" , y = "Values" , x = "index" )

p30 <- co2_present%>%ACF(average, lag_max = 48)%>%autoplot() + labs("title = CO2 levels")


grid.arrange(p29,p30, nrow = 1, ncol = 2)

```
### (1 point) Task 2b: Compare linear model forecasts against realized CO2 [Weekly Data]
Descriptively compare realized atmospheric CO2 levels to those predicted by your forecast from a linear time model in 1997 (i.e. "Task 2a"). (You do not need to run any formal tests for this task.) 

```{r include=FALSE}

# LINEAR TREND (Modelling)

fit_linear <- co2_present%>% model(trend_model = TSLM(average ~ trend()))

```

```{r include=FALSE}
co2_present_linear <- subset(co2_present, select = c("average", "index"))
co2_present_linear

```

```{r include=FALSE}
class(co2_present_linear)
```

```{r include=FALSE}
# OMITTING VALUE FROM THE Null dataframe rows 

co2_present <- na.omit(co2_present)

co2_present <- co2_present %>%
  as_tsibble(index=index)
```


```{r include=FALSE}
# QUADRATIC TREND 

fit_quadratic <- co2_present %>%model(model_trend = TSLM(average ~ trend() + I(trend()^2 )))

```


```{r , echo = FALSE , fig.height=3}
p38 <- augment(fit_quadratic)%>% ggplot(aes(x= index)) +
  geom_line(aes(y= average, color = "Data")) + 
  geom_line(aes(y= .fitted , color = "Fitted")) +
  labs( y = "Time" , title = "CO2 Quadratic trend in US")

p38

```

```{r include=FALSE}
# # fit linear Season
co2_present_linear_season <- co2_present%>%group_by(yearmonth(index))%>%summarise(average)

co2_present_linear_season
```

```{r include=FALSE}
co2_present_linear_season <- co2_present_linear_season[,c("yearmonth(index)", "average")]
co2_present_linear_season
```

### (1 point) Task 3b: Compare ARIMA models forecasts against realized CO2 

```{r include=FALSE}
# MODEL BUILDING USINF AIC

co2_present <- tsibble::fill_gaps(co2_present)

model.aic<-co2_present %>%
  model(ARIMA(average ~ 0:1 + pdq(0:8,0:2,0:8) + PDQ(0:8,0:2,0:8), ic="aic", stepwise=F, greedy=F))

model.aic %>%
  report()
```


```{r include=FALSE}
# MODEL BUILDING USINF AIC adjusted

model.aicc<-co2_present %>%model(ARIMA(average ~ 0:1 + pdq(0:8,0:2,0:8) + PDQ(0:8,0:2,0:8), ic="aicc", stepwise=F, greedy=F))

model.aicc %>%
  report()

```


```{r include=FALSE}
# MODEL BUILDING USINF BIC adjusted

model.bic<-co2_present %>%
  model(ARIMA(average ~ 0:1 + pdq(0:8,0:2,0:8) + PDQ(0:8,0:2,0:8), ic="bic", stepwise=F, greedy=F))

model.bic %>%
  report()

```

### 4B.(3 points) Task 4b: Evaluate the performance of 1997 linear and ARIMA models 
**Ques:*In 1997 you made predictions about the first time that CO2 would cross 420 ppm. How close were your models to the truth? .After reflecting on your performance on this threshold-prediction task, continue to use the weekly data to generate a month-average series from 1997 to the present, and compare the overall forecasting performance of your models from Parts 2a and 3b over the entire period. (You should conduct formal tests for this task.) 

**Observations:**In the previous section, we conducted exploratory data analysis to visually assess the forecast of both the linear model and ARIMA model for atmospheric C02 levels. These models captured the historic trends and patterns effectively up to a certain point 1997. However as we moved from 1997, the forecasted lines started to deviate, making it challenging to determine which model better fits the data. To quantitatively evaluate the accuracy of the models, we conducted a formal evaluation using the Root Mean Squared Error (RMSE) test. Both the ARIMA and linear models were developed using data from 1974 to 1993. We used these models to forecast the atmospheric CO2 levels until 2023. Since models were built on a monthly dataset, the predictions we obtained were also on a monthly basis for the period from 1993 to 2023. 

To ensure a fair comparison of these predictions we aggregated the current dataset to a monthly level. The model performance of ARIMA model , after comparing its predictions with the current dataset, resulted in an RMSE of 51.66 On the other hand, the linear model which considered both the seasonal and trend components, had an RMSE of 14.037. It looks like that data has certain trend and pattern which are better captured by linear regression.


```{r include=FALSE}
co2_present <- read.table("co2_weekly_mlo.csv", sep = ",", header = TRUE)

co2_present <- co2_new %>%
  mutate(date = paste(year, month, day, sep = "-")) %>%
  mutate(index = as.Date(date)) %>%
  filter(year(date) >= 1997, average > 0) %>%
  as_tsibble(index = index)

co2_present
```


```{r include=FALSE}

# AGREGATE DATA BY MONTH
co2_present
```

```{r include=FALSE}
co2_present <- co2_present %>%
  unite(year_month, year, month, sep = "-")
```


```{r include=FALSE}
co2_present <- co2_present[,c("average","year_month")]
```



```{r include=FALSE}
# Aggregating current CO2 dataset monthly 

co2_present <- co2_present %>%
  mutate(index = year_month) 


co2_present_monthly <- co2_present %>%
  group_by(index) %>%
  summarize(average = mean(average))

co2_present_monthly

```
```{r include=FALSE}
co2_present_monthly
```

```{r include=FALSE}
# Create the year-month combination as a new column
co2_present_monthly <- co2_present_monthly %>%
  mutate(yearmonth = yearmonth(index))

# Group by the year-month combination and calculate the mean of averages
co2_present_monthly <- co2_present_monthly %>%
  group_by(yearmonth) %>%
  summarize(mean_average = mean(average))

co2_present_monthly
```
```{r include=FALSE}
co2_present_monthly <- co2_present_monthly[c("yearmonth" ,"mean_average" )]
co2_present_monthly
```
```{r include=FALSE}
# Assuming your tsibble object is named "selected_data"
co2_present_monthly <- co2_present_monthly %>%
  group_by(yearmonth) %>%
  summarize(mean_average = mean(mean_average))
co2_present_monthly
```

```{r include=FALSE}
co2_present_monthly <- co2_present_monthly %>%
  as_tsibble(index = yearmonth)
co2_present_monthly
```
```{r include=FALSE}
co2_present_monthly <- co2_present_monthly %>%
  rename(index = yearmonth)

# Print the updated tsibble
print(co2_present_monthly)
```


```{r , echo = FALSE , fig.height=3}
# OLD LINEAR MODEL 1997

# fit linear Season

co2 <- co2%>%as_tsibble()
fit_linear_season <- co2%>%model(model_trend =  TSLM(value ~ trend() + season() ))

p39 <- augment(fit_linear_season)%>%ggplot(aes(x=index)) +
  geom_line(aes(y = value , color = "Data"))  + 
  geom_line(aes(y = .fitted , color = "Fitted")) + 
  labs( y= "Time" , title = " C02 Fit linear season")
p39
```

```{r include=FALSE}

# OLD ARIMA MODEL 1997

# fit ARIMA Model

model.bic<-co2 %>%
  model(fable::ARIMA(value ~ 0:1 + pdq(0:8,0:2,0:8) + 
                       PDQ(0:12,0:4,0:12, period=12),
                     ic="bic", stepwise=F, greedy=F))

model.bic %>%
  report()
```

```{r include=FALSE}
# Forecast of ARIMA model from Section 1 for the period Jan 1997 to Dec 2023

test.size = 12*26

model.forecasts_ARIMA <-forecast(model.bic, h=test.size)
model.forecasts_ARIMA

```


```{r include=FALSE}

# Comparision of ARIMA model prediction from Section 1 and Present CO2 values for the period Jan 1997 to Dec 2023

library(dplyr)

# Assuming model.forecasts and co2_present_monthly are your data frames

# Merge the two data frames on the 'index' column, and handle missing values with 0
merged_df <- merge(model.forecasts_ARIMA, co2_present_monthly, by = "index", all.x = TRUE)
merged_df[is.na(merged_df)] <- 0  # Replace missing values with 0

# Select the desired columns and rename them if needed
selected_df <- merged_df %>%
  select(index, .mean, mean_average) %>%
  rename(predicted = .mean, current_value = mean_average)

# Print the result
print(selected_df)




```


```{r , echo = FALSE}

# After comparision, Evaluate performance of ARIMA MODEL from Section 1 on the Present CO2 Dataset for the period Jan 1997 to Dec 2023

selected_df$diff_squared <- (selected_df$predicted - selected_df$current_value)^2

# Calculate the RMSE
rmse <- sqrt(mean(selected_df$diff_squared))

# Print the RMSE
print(paste("Root Mean Squared Error (RMSE):", rmse))

```

```{r include=FALSE}

#  Forecast of LINEAR model from Section 1 for the period Jan 1997 to Dec 2023

test.size = 12*26

model.forecasts_linear <-forecast(fit_linear_season, h=test.size)
model.forecasts_linear 
```

```{r include=FALSE}

# Comparision of LINEAR model prediction from Section 1 for the period Jan 1997 to Dec 2023 and Present CO2 values for the period Jan 1997 to Dec 2023

library(dplyr)

# Assuming model.forecasts and co2_present_monthly are your data frames

# Merge the two data frames on the 'index' column, and handle missing values with 0
merged_df_linear  <- merge(model.forecasts_linear , co2_present_monthly, by = "index", all.x = TRUE)
merged_df_linear[is.na(merged_df)] <- 0  # Replace missing values with 0

# Select the desired columns and rename them if needed
selected_df_linear  <- merged_df_linear %>%
  select(index, .mean, mean_average) %>%
  rename(predicted = .mean, current_value = mean_average)

# Print the result
print(selected_df_linear)
```

```{r , echo = FALSE}

# After comparision, Evaluate performance of LINEAR MODEL from Section 1 on the Present CO2 Dataset for the period Jan 1997 to Dec 2023

# Remove rows with missing values in 'predicted' or 'current_value'
selected_df_linear <- selected_df_linear[complete.cases(selected_df_linear[c('predicted', 'current_value')]), ]

# Calculate the squared differences between 'predicted' and 'current_value'
selected_df_linear$diff_squared <- (selected_df_linear$predicted - selected_df_linear$current_value)^2

# Calculate the RMSE
rmse <- sqrt(mean(selected_df_linear$diff_squared))

# Print the RMSE
print(paste("Root Mean Squared Error (RMSE):", rmse))

```


### (4 points) Task 5b: Train best models on present data
**Ques:**Seasonally adjust the weekly NOAA data, and split both seasonally-adjusted (SA) and non-seasonally-adjusted (NSA) series into training and test sets, using the last two years of observations as the test sets. For both SA and NSA series, fit ARIMA models using all appropriate steps. Measure and discuss how your models perform in-sample and (psuedo-) out-of-sample, comparing candidate models and explaining your choice. In addition, fit a polynomial time-trend model to the seasonally-adjusted series and compare its performance to that of your ARIMA model.

**Analysis:**
In the previous section, we performed a comprehensive evaluation of models trained on 1997 dataset with the focus on long term forecasting 1998 to 2023 and got high residual error. However, for long term forecasting, utilizing seasonally adjusted data becomes more appropriate. To accomplish this we applied the STL method, which effectively decomposes the time series and provides us with seasonal adjusted data. This dataset was subsequently split into training (1997 to 2021) and test (2021 to 2023) sets to assess model performance.

The ARIMA models were trained on the training dataset and evaluated on the test dataset, yielding an RMSE value of 0.142. Similarly we conducted a parallel analysis on the non seasonal adjusted data, resulting in an RMSE value of 0.140. Interestingly, the non-seasonally adjusted ARIMA model showcased slightly better performance than its seasonally adjusted counterpart.

During the training process, we employed a grid search, exploring various parameter combinations (p, d, q) ranging from (0:8, 0:2, 0:8) and seasonal parameter combinations (P, D, Q) spanning from (0:12, 0:4, 0:12). The final selected ARIMA model was (0,1,1)(4,0,0)[12], indicating the implementation of differencing once for stationarity and incorporating one lag of forecast errors. This model demonstrated improved performance on the out-of-sample test dataset compared to the ARIMA model built in the previous section. This improvement in predictive capabilities can be attributed to the inclusion of more recent training data from 1997 to 2020, which allowed the model to forecast the immediate future (2021 to 2023) more accurately. Also, the ARIMA model performs well both on in-sample and out-sample, indicating that model is flexible and able to predict accurately and not overfitting.

Additionally, we compared the non-seasonally adjusted ARIMA model with a polynomial linear model trained on seasonally adjusted data. The RMSE value for the polynomial linear model was 1.7, whereas the non-seasonally adjusted ARIMA model achieved an RMSE of 0.14. The non-seasonally adjusted ARIMA model showcased superior performance in predicting the immediate future and effectively capturing the seasonal pattern. Also, as seen from the EDA, the seasonal pattern is stable in this data. Conversely, the polynomial linear model on seasonally adjusted data is better for predicting long-term trends and not as effective in capturing seasonal variations. Overall, our analysis highlighted the significance of selecting the appropriate modeling approach based on the forecasting requirements and the nature of the data.







```{r include=FALSE , warning=FALSE}
# # Seasonally adjusted data by Smoothing - To have a clearer view of the trend, we can remove the seasonal movement by aggregating the data to the annual level.
# from the graph it appears that there is a good upward trend agregating the seasons
# CO2 presents extration for period > 1997 and average > 0

co2_present <- read.table("co2_weekly_mlo.csv", sep = ",", header = TRUE)

co2_present <- co2_present %>%
  mutate(date = paste(year, month, day, sep = "-")) %>%
  mutate(index = as.Date(date)) %>%
  filter(year(date) >= 1997, average > 0) %>%
  as_tsibble(index = index)

co2_present
```

```{r include=FALSE}
co2_present_yearly <- co2_present[c("year", "average")]
co2_present_yearly
```

```{r include=FALSE}
# Aggregated data Yearly 

co2_present_yearly_aggregate <- co2_present_yearly %>%
  #mutate(year = year(index))%>%
  group_by(year) %>%
  summarize(average = mean(average))

# Print the result
print(co2_present_yearly_aggregate)
```

```{r include=FALSE}
library(dplyr)
library(lubridate)

p26 <- co2_present %>%
  mutate(year = year(index)) %>%
  group_by(year) %>%
  summarise(avg_total = sum(average)) %>%
  ggplot(aes(x = year, y = avg_total)) +
  geom_line() + 
  labs(title = "Aggregating by year", y = "Values", x = "Time")

p26


```

```{r include=FALSE}
co2_present_yearly_aggregate
```

```{r include=FALSE}
# CO2 data yearly aggregated

co2_present_yearly_aggregate <- co2_present_yearly_aggregate %>%
  arrange(desc(year))

# Extract the last two years for the test dataset
test_data <- co2_present_yearly_aggregate %>%
  slice(1:2)

# Extract the remaining data for the training dataset
train_data <- co2_present_yearly_aggregate %>%
  slice(-(1:2))

# Print the test and train datasets
print("Test Data:")
print(test_data)

print("Training Data:")
print(train_data)
```

```{r include=FALSE}

# ARIMA model development on training dataset for the period Jan 1997 to Dec 2021

library("fabletools")

train_data <- train_data%>%as_tsibble(index = year)

model.bic_yearly <-train_data %>%
  model(fable::ARIMA(average ~ 0:1 + pdq(0:8,0:2,0:8) + 
                       PDQ(0:12,0:4,0:12, period=12),
                     ic="bic", stepwise=F, greedy=F))

model.bic_yearly %>%
  report()
```

```{r include=FALSE}
# Forecasts of Section 2 ARIMA model on Train Dataset [Jan 2022 to Dec 2023]

test.size = 2

model.forecasts_ARIMA_yearly <-forecast(model.bic_yearly, h=test.size)
model.forecasts_ARIMA_yearly

```

```{r include=FALSE}
test_data
```


```{r include=FALSE}

# Comparision of the ARIMA model prediction made in Section 2 for the period Jan 2022 to Dec 2023 with the Present actual CO2 values observed for the period Jan 2022 to Dec 2023

library(dplyr)

# Assuming model.forecasts and co2_present_monthly are your data frames

# Merge the two data frames on the 'index' column, and handle missing values with 0
merged_df_yearly <- merge(model.forecasts_ARIMA_yearly, test_data, by = "year", all.x = TRUE)
# merged_df_yearly[is.na(merged_df)] <- 0  # Replace missing values with 0

# Select the desired columns and rename them if needed
selected_df_yearly <- merged_df_yearly %>%
  select(year, average.y , .mean) %>%
  rename(predicted = .mean, current_value = average.y)

# Print the result
print(selected_df_yearly)
```


```{r include=FALSE}
# #After comparision, Evaluate performance of ARIMA MODEL from Section 2 on the Present CO2 Dataset for the period Jan 2022 to Dec 2023

# Remove rows with missing values in 'predicted' or 'current_value'
# selected_df_linear <- selected_df_linear[complete.cases(selected_df_linear[c('predicted', 'current_value')]), ]

# Calculate the squared differences between 'predicted' and 'current_value'
selected_df_yearly$diff_squared <- (selected_df_yearly$predicted - selected_df_yearly$current_value)^2

# Calculate the RMSE
rmse_yearly <- sqrt(mean(selected_df_yearly$diff_squared))

# Print the RMSE
print(paste("Root Mean Squared Error (RMSE):", rmse_yearly))

```

```{r include=FALSE}
train_data
```

```{r , echo = FALSE, fig.height=3 , include=FALSE}
# LINEAR model development on Training dataset for the period Jan 1997 to Dec 2021

train_data <- train_data%>%as_tsibble()
fit_linear_season_yeary <- train_data%>%model(model_trend =  TSLM(average ~ trend() + season() ))

p39 <- augment(fit_linear_season_yeary)%>%ggplot(aes(x=year)) +
  geom_line(aes(y = average , color = "Data"))  + 
  geom_line(aes(y = .fitted , color = "Fitted")) + 
  labs( y= "Time" , title = " C02 Fit linear season")
p39

```

```{r include=FALSE}
# Forecasts of Section 2 LINEAR model on Test Dataset [Jan 2022 to Dec 2023]

test.size = 2

model.forecasts_linear_yearly <-forecast(fit_linear_season_yeary, h=test.size)
model.forecasts_linear_yearly  
```

```{r include=FALSE}
co2_present_monthly
```

```{r include=FALSE}
# Merging Predictions from ARIMA Model and Current Values

library(dplyr)

# Assuming model.forecasts and co2_present_monthly are your data frames

# Merge the two data frames on the 'index' column, and handle missing values with 0
merged_df_yearly_linear <- merge(model.forecasts_linear_yearly, test_data, by = "year", all.x = TRUE)
# merged_df_yearly[is.na(merged_df)] <- 0  # Replace missing values with 0

# Select the desired columns and rename them if needed
selected_df_yearly_linear <- merged_df_yearly_linear %>%
  select(year, average.y , .mean) %>%
  rename(predicted = .mean, current_value = average.y)

# Print the result
print(selected_df_yearly_linear)
```


```{r include=FALSE}
# #After comparision, Evaluate performance of ARIMA MODEL from Section 2 on the Present CO2 Dataset for the period Jan 2022 to Dec 2023

# Remove rows with missing values in 'predicted' or 'current_value'
# selected_df_linear <- selected_df_linear[complete.cases(selected_df_linear[c('predicted', 'current_value')]), ]

# Calculate the squared differences between 'predicted' and 'current_value'
selected_df_yearly_linear$diff_squared <- (selected_df_yearly_linear$predicted - selected_df_yearly_linear$current_value)^2

# Calculate the RMSE
rmse_yearly <- sqrt(mean(selected_df_yearly_linear$diff_squared))

# Print the RMSE
print(paste("Root Mean Squared Error (RMSE):", rmse_yearly))

```


```{r include=FALSE}
# CO2 presents extration for period > 1997 and average > 0

co2_present <- read.table("co2_weekly_mlo.csv", sep = ",", header = TRUE)

co2_present <- co2_present %>%
  mutate(date = paste(year, month, day, sep = "-")) %>%
  mutate(index = as.Date(date)) %>%
  filter(year(date) >= 1997, average > 0) %>%
  as_tsibble(index = index)

co2_present
```

```{r include=FALSE}
co2_present_reduced <- co2_present%>%select(average , index)
co2_present_reduced
```

```{r include=FALSE}
# IMPORTANT CODE 
library(tsibble)
library(dplyr)
library(stats)
library(lubridate)

co2_present_reduced1 <- as_tsibble(co2_present_reduced)

# Create the year-month combination as a new column
co2_present_reduced2 <- co2_present_reduced1 %>%
  mutate(yearmonth = yearmonth(index))

# Group by the year-month combination and calculate the mean of averages
co2_present_yearlymonthly <- co2_present_reduced2 %>%
  group_by(yearmonth) %>%
  summarize(mean_average = mean(average))

co2_present_yearlymonthly
```


```{r include=FALSE}
# Extracted certain columns but getting Tibble object 

selected_data2 <- co2_present_yearlymonthly[c("yearmonth" ,"mean_average" )]
selected_data2
```

```{r include=FALSE}
# Aggregating Tibble object by Yearmonth

library(dplyr)

# Assuming your tsibble object is named "selected_data"
grouped_data <- selected_data2 %>%
  group_by(yearmonth) %>%
  summarize(mean_average = mean(mean_average))
grouped_data
```

```{r include=FALSE}
# Converting Tibble to Tsibble

library(tsibble)

# Assuming your tibble is named "your_tibble"
tsbl_data <- grouped_data %>%
  as_tsibble(index = yearmonth)
tsbl_data
```


```{r include=FALSE}
#### SEASONALLY ADJUSTED Dataset through STL for the period Jan 1997 to Dec 2021
# DECOMPOSING TIME SERIES

library(feasts)
library(fabletools)

dcmp_add <- tsbl_data %>%
  model(stl = STL(mean_average))

dcmp_multi <- tsbl_data %>%
  model(stl = STL(mean_average))
```


```{r include=FALSE}
# library(dplyr)
# library(gridExtra)

# p31 <- components(dcmp_add) %>%
#  as_tsibble() %>%
#  autoplot(average, colour="gray") +
#  geom_line(aes(y=trend), colour = "#D55E00") +

#  labs(y = "Value", x="Index",
#    title = "CO2 Levels")

# p32 <- components(dcmp_multi) %>%
#  as_tsibble() %>%
#  autoplot(average, colour="gray") +
#  geom_line(aes(y=value), colour = "#D55E00") +
#  labs(y = "Value", x="Index",
#    title = "log of CO2 Levels")

# grid.arrange(p31,p32, nrow = 1, ncol =2)

```


```{r , echo = FALSE, fig.height=3 }

# Extracting the Trend, Seasonal, and Remainder components from the dataset after applying seasonal adjustment through # STL for the period Jan 1997 to Dec 2021

library(fable)
library(fabletools)
library(ggplot2)
library(gridExtra)

p33 <- components(dcmp_add) %>% autoplot()

p34<- components(dcmp_add)%>%
  ACF(remainder) %>%
  autoplot() + labs(title="Residuals additive decomposition")

p35 <- components(dcmp_multi) %>% autoplot()

p36<- components(dcmp_multi)%>%
  ACF(remainder) %>%
  autoplot() + labs(title="Residuals of multiplicative decomposition")

grid.arrange(p33,p34,p35 ,p36, nrow = 2, ncol = 2)

```

```{r include=FALSE}
p31_1 <- components(dcmp_add) %>%
   as_tsibble() 

p31_1

```

```{r include=FALSE}
seasonally_adjusted_STL <- p31_1%>%select(yearmonth , season_adjust)
seasonally_adjusted_STL
```

```{r include=FALSE}

#seasonally_adjusted_STL[nrow(seasonally_adjusted_STL - 24): nrow(seasonally_adjusted_STL),]
rows <- nrow(seasonally_adjusted_STL)
test_data <- seasonally_adjusted_STL[(rows-24): rows,]
train_data <- seasonally_adjusted_STL[0: (rows-24),]
```

```{r include=FALSE}
train_data
```
```{r include=FALSE}
test_data
```


```{r include=FALSE}
## Using Seasonally Adjusted data through STL for ARIMA

# ARIMA model development on training dataset for the period Jan 1997 to Dec 2021

# ARIMA model development on training dataset for the period Jan 1997 to Dec 2021

library("fabletools")

train_data <- train_data%>%as_tsibble(index = yearmonth)

model.bic_monthlyyearly <-train_data %>%
  model(fable::ARIMA(season_adjust ~ 0:1 + pdq(0:8,0:2,0:8) + 
                       PDQ(0:12,0:4,0:12, period=12),
                     ic="bic", stepwise=F, greedy=F))

model.bic_monthlyyearly %>%
  report()
```

```{r include=FALSE}
# Forecasts of Section 2 ARIMA model on Train Dataset [Jan 2022 to Dec 2023]

test.size = 2

model.forecasts_ARIMA_yearly <-forecast(model.bic_monthlyyearly, h=test.size)
model.forecasts_ARIMA_yearly

```

```{r include=FALSE}
test_data
```

```{r include=FALSE}

# Comparision of the ARIMA model prediction made in Section 2 for the period Jan 2022 to Dec 2023 with the Present actual CO2 values observed for the period Jan 2022 to Dec 2023

library(dplyr)

# Assuming model.forecasts and co2_present_monthly are your data frames

# Merge the two data frames on the 'index' column, and handle missing values with 0
merged_df_yearly <- merge(model.forecasts_ARIMA_yearly, test_data, by = "yearmonth", all.x = TRUE)
# merged_df_yearly[is.na(merged_df)] <- 0  # Replace missing values with 0

# Select the desired columns and rename them if needed
selected_df_yearly <- merged_df_yearly %>%
  select(yearmonth, season_adjust.y , .mean) %>%
  rename(predicted = .mean, current_value = season_adjust.y)

# Print the result
print(selected_df_yearly)
```

```{r include=FALSE}
# #After comparision, Evaluate performance of ARIMA MODEL from Section 2 on the Present CO2 Dataset for the period Jan 2022 to Dec 2023

# Remove rows with missing values in 'predicted' or 'current_value'
# selected_df_linear <- selected_df_linear[complete.cases(selected_df_linear[c('predicted', 'current_value')]), ]

# Calculate the squared differences between 'predicted' and 'current_value'
selected_df_yearly$diff_squared <- (selected_df_yearly$predicted - selected_df_yearly$current_value)^2

# Calculate the RMSE
rmse_yearly <- sqrt(mean(selected_df_yearly$diff_squared))

# Print the RMSE
print(paste("Root Mean Squared Error (RMSE):", rmse_yearly))

```


```{r include=FALSE}
train_data
```


```{r , echo = FALSE , fig.height=3}
# Forecasts of Section 2 ARIMA model on Train Dataset [Jan 2022 to Dec 2023]

# LINEAR model development on Training dataset for the period Jan 1997 to Dec 2021

train_data <- train_data%>%as_tsibble()
fit_linear_season_yeary <- train_data%>%model(model_trend =  TSLM(season_adjust ~ trend() + season() ))

p39 <- augment(fit_linear_season_yeary)%>%ggplot(aes(x=yearmonth)) +
  geom_line(aes(y = season_adjust , color = "Data"))  + 
  geom_line(aes(y = .fitted , color = "Fitted")) + 
  labs( y= "Time" , title = " C02 Fit linear season")
p39

```

```{r include=FALSE}
# Forecasts of Section 2 LINEAR model on Test Dataset [Jan 2022 to Dec 2023]

test.size = 2

model.forecasts_linear_yearly <-forecast(fit_linear_season_yeary, h=test.size)
model.forecasts_linear_yearly  
```

```{r include=FALSE}
# Comparision of the LINEAR model prediction made in Section 2 for the period Jan 2022 to Dec 2023 with the Present # actual CO2 values observed for the period Jan 2022 to Dec 2023

# Merging Predictions from ARIMA Model and Current Values

library(dplyr)

# Assuming model.forecasts and co2_present_monthly are your data frames

# Merge the two data frames on the 'index' column, and handle missing values with 0
merged_df_yearly_linear <- merge(model.forecasts_linear_yearly, test_data, by = "yearmonth", all.x = TRUE)
# merged_df_yearly[is.na(merged_df)] <- 0  # Replace missing values with 0

# Select the desired columns and rename them if needed
selected_df_yearly_linear <- merged_df_yearly_linear %>%
  select(yearmonth, season_adjust.y , .mean) %>%
  rename(predicted = .mean, current_value = season_adjust.y)

# Print the result
print(selected_df_yearly_linear)
```


```{r echo=FALSE}
# #After comparision, Evaluate performance of ARIMA MODEL from Section 2 on the Present CO2 Dataset for the period Jan 2022 to Dec 2023

# Remove rows with missing values in 'predicted' or 'current_value'
# selected_df_linear <- selected_df_linear[complete.cases(selected_df_linear[c('predicted', 'current_value')]), ]

# Calculate the squared differences between 'predicted' and 'current_value'
selected_df_yearly_linear$diff_squared <- (selected_df_yearly_linear$predicted - selected_df_yearly_linear$current_value)^2

# Calculate the RMSE
rmse_yearly <- sqrt(mean(selected_df_yearly_linear$diff_squared))

# Print the RMSE
print(paste("Root Mean Squared Error (RMSE):", rmse_yearly))

```

```{r include=FALSE}
## ** The RMSE of the linear model is 1.567, but the RMSE of the ARIMA model is 0.11932, which is smaller. Therefore, # the ARIMA model is a better model**

### Non-seasonally Adjusted Dataset

# CO2 presents extration for period > 1997 and average > 0

co2_present <- read.table("co2_weekly_mlo.csv", sep = ",", header = TRUE)

co2_present <- co2_present %>%
  mutate(date = paste(year, month, day, sep = "-")) %>%
  mutate(index = as.Date(date)) %>%
  filter(year(date) >= 1997, average > 0) %>%
  as_tsibble(index = index)

co2_present
```

```{r include=FALSE}
co2_present_reduced_weekly <- co2_present[c("average" ,"index")]
co2_present_reduced_weekly

```

```{r include=FALSE}
co2_present_reduced_weekly <- co2_present_reduced_weekly %>%
  mutate(yearweek = yearweek(index))
co2_present_reduced_weekly
```

```{r include=FALSE}
# Assuming your tsibble object is named "selected_data"
co2_present_reduced_weekly_group <- co2_present_reduced_weekly %>%
  group_by(yearweek) %>%
  summarize(mean_average = mean(average))
co2_present_reduced_weekly_group
```

```{r include=FALSE}
co2_present_reduced_weekly_group <- co2_present_reduced_weekly_group[c("yearweek" , "mean_average")]
co2_present_reduced_weekly_group

```


```{r include=FALSE}
library(tsibble)

# Assuming your tibble is named "your_tibble"
co2_present_reduced_weekly_group <- co2_present_reduced_weekly_group %>%
  as_tsibble(index = yearweek)
co2_present_reduced_weekly_group
```

```{r include=FALSE}

co2_present_reduced_weekly_group <- co2_present_reduced_weekly_group %>%
  as_tsibble(index=yearweek)
co2_present_reduced_weekly_group

```

```{r include=FALSE}
# CO2 data Split into Train and Test Non-Seasonally Adjusted Dataset 

co2_present_reduced_weekly_group <- co2_present_reduced_weekly_group %>%
  arrange(desc(yearweek))

# Extract the last two years for the test dataset
test_data <- co2_present_reduced_weekly_group %>%
  slice(1:96)

# Extract the remaining data for the training dataset
train_data <- co2_present_reduced_weekly_group %>%
  slice(-(1:96))

# Print the train datasets
print("Training Data:")
print(train_data)

# Print the test 
print("Test Data:")
print(test_data)

```


```{r include=FALSE}

# ARIMA model development on Non-seasonally adjusted training dataset for the period Jan 1997 to Dec 2021
library("fabletools")

# Filling gaps
train_data <- tsibble::fill_gaps(train_data)

# Developing model from non-seasonal adjusted dataset
model.bic_weekly <-train_data %>%
  model(fable::ARIMA(mean_average ~ 0:1 + pdq(0:8,0:2,0:8) + 
                       PDQ(0:12,0:4,0:12, period=12),
                     ic="bic", stepwise=F, greedy=F))

 model.bic_weekly %>%
  report()
```

```{r include=FALSE}
# Forecasts of Section 2 ARIMA model on Non-seasonally adjusted Train Dataset [Jan 2022 to Dec 2023]

test.size = 96

model.forecasts_ARIMA_weekly <-forecast(model.bic_weekly, h=test.size)
model.forecasts_ARIMA_weekly

```

```{r include=FALSE}

# Comparision of the ARIMA model prediction made in Section 2 for the period Jan 2022 to Dec 2023 with the Present actual CO2 values observed for the period Jan 2022 to Dec 2023

library(dplyr)

# Assuming model.forecasts and co2_present_monthly are your data frames

# Merge the two data frames on the 'index' column, and handle missing values with 0
merged_df_weekly <- merge(model.forecasts_ARIMA_weekly, test_data, by = "yearweek", all.x = TRUE)
# merged_df_yearly[is.na(merged_df)] <- 0  # Replace missing values with 0

# Select the desired columns and rename them if needed
selected_df_weekly <- merged_df_weekly %>%
  select(yearweek, mean_average.y , .mean) %>%
  rename(predicted = .mean, current_value = mean_average.y)

# Print the result
print(selected_df_weekly)
```

```{r echo=FALSE}
# #After comparision, Evaluate performance of ARIMA MODEL from Section 2 on the Present CO2 Dataset for the period Jan 2022 to Dec 2023

# Remove rows with missing values in 'predicted' or 'current_value'
# selected_df_linear <- selected_df_linear[complete.cases(selected_df_linear[c('predicted', 'current_value')]), ]

# Calculate the squared differences between 'predicted' and 'current_value'
selected_df_weekly$diff_squared <- (selected_df_weekly$predicted - selected_df_weekly$current_value)^2

# Calculate the RMSE
rmse_yearly <- sqrt(mean(selected_df_yearly$diff_squared))

# Print the RMSE
print(paste("Root Mean Squared Error (RMSE):", rmse_yearly))

```


```{r , echo = FALSE, fig.height=3 }
## Using NON- Seasonally Adjusted data for LINEAR
# LINEAR model development on NON- Seasonally Adjusted Training dataset for the period Jan 1997 to Dec 2021

train_data <- train_data%>%as_tsibble()
fit_linear_NON_season_weekly <- train_data%>%model(model_trend =  TSLM(mean_average ~ trend() + season() ))

p39 <- augment(fit_linear_NON_season_weekly)%>%ggplot(aes(x=yearweek)) +
  geom_line(aes(y = mean_average , color = "Data"))  + 
  geom_line(aes(y = .fitted , color = "Fitted")) + 
  labs( y= "Time" , title = " C02 Fit linear season")
p39

```

```{r include=FALSE}
# Forecasts of Section 2 LINEAR model on NON- Seasonally Adjusted Test Dataset [Jan 2022 to Dec 2023]

test.size = 96

model.forecasts_weekly_non_seasonal <-forecast(fit_linear_NON_season_weekly, h=test.size)
model.forecasts_weekly_non_seasonal  
```

```{r include=FALSE}
# Comparision of the LINEAR model prediction made in Section 2 NON- Seasonally Adjusted for the period Jan 2022 to Dec # 2023 with the Present actual CO2 values observed for the period Jan 2022 to Dec 2023

# Merging Predictions from ARIMA Model and Current Values for NON- Seasonally Adjusted Dataset

library(dplyr)

# Assuming model.forecasts and co2_present_monthly are your data frames

# Merge the two data frames on the 'index' column, and handle missing values with 0
merged_df_weekly_non_seasonal <- merge(model.forecasts_weekly_non_seasonal, test_data, by = "yearweek", all.x = TRUE)
# merged_df_yearly[is.na(merged_df)] <- 0  # Replace missing values with 0

# Select the desired columns and rename them if needed
selected_weekly_non_seasonal <- merged_df_weekly_non_seasonal %>%
  select(yearweek, mean_average.y , .mean) %>%
  rename(predicted = .mean, current_value = mean_average.y)

# Print the result
print(selected_weekly_non_seasonal)
```

```{r echo=FALSE}
# #After comparision, Evaluate performance of ARIMA MODEL from Section 2 on the Present CO2 Dataset for the period Jan 2022 to Dec 2023

# Remove rows with missing values in 'predicted' or 'current_value'
# selected_df_linear <- selected_df_linear[complete.cases(selected_df_linear[c('predicted', 'current_value')]), ]

# Calculate the squared differences between 'predicted' and 'current_value'
selected_weekly_non_seasonal$diff_squared <- (selected_weekly_non_seasonal$predicted - selected_weekly_non_seasonal$current_value)^2

# Calculate the RMSE
rmse_weekly_non_seasonal <- sqrt(mean(selected_weekly_non_seasonal$diff_squared))

# Print the RMSE
print(paste("Root Mean Squared Error (RMSE):", rmse_weekly_non_seasonal))


## ** The RMSE of the linear model is 1.78, but the RMSE of the ARIMA model is 0.11932, which is smaller. Therefore, the ARIMA model is a better model**

```


### (3 points) Task Part 6b: How bad could it get?

With the non-seasonally adjusted data series, generate predictions for when atmospheric CO2 is expected to be at 420 ppm and 500 ppm levels for the first and final times (consider prediction intervals as well as point estimates in your answer). Generate a prediction for atmospheric CO2 levels in the year 2122. How confident are you that these will be accurate predictions?



```{r include=FALSE}
test.size = 12784 # weekly time series unit

model.forecasts_ARIMA_weekly <-forecast(model.bic_weekly, h=test.size)
model.forecasts_ARIMA_weekly
```


```{r include=FALSE}
# Forecasts of Section2 ARIMA model for the period [Jan 2022 to Dec 2122]

test.size = 12784 # weekly time series unit

model.forecasts_ARIMA_weekly <-forecast(model.bic_weekly, h=test.size)
model.forecasts_ARIMA_weekly
```


```{r include=FALSE}
# predicted co2 value 420 
# Whether 420ppm CO2 present in data or not?
# period for [Jan 2022 to Dec 2122]

library(dplyr)

# Assuming your model.forecasts_ARIMA_weekly contains the columns 'date' and '.mean'

# Check if there is any value near 420 (within a range of +/- 10) in the .mean column
value_420ppm <- any(abs(model.forecasts_ARIMA_weekly$.mean - 420) <= 10)

# Print the result
print(value_420ppm)

# **420 ppm CO2 level is not present in the forecasted data until the year 2122. Hence upper and lower bound doesnt # exist either.**

```


 
```{r include=FALSE}
# predicted co2 value 500
# Whether 500ppm CO2 present in data or not?
# period for [Jan 2022 to Dec 2122]

library(dplyr)

# Assuming your model.forecasts_ARIMA_weekly contains the columns 'date' and '.mean'

# Check if there is any value near 420 (within a range of +/- 10) in the .mean column
value_500ppm <- any(abs(model.forecasts_ARIMA_weekly$.mean - 500) <= 10)

# Print the result
print(value_500ppm)

# **500 ppm CO2 level is not present in the forecasted data until the year 2122.Hence upper and lower bound doesnt # exist either.**
```



Generate a prediction for atmospheric CO2 levels in the year 2100. How confident are you that these will be accurate predictions?

```{r include=FALSE}
# ## Confidence interval

model.forecasts_ARIMA_weekly_confidence_interval <-model.forecasts_ARIMA_weekly %>% mutate(upper=quantile(.mean,0.95),lower=quantile(.mean,0.05))
model.forecasts_ARIMA_weekly_confidence_interval

```

```{r include=FALSE}
library(dplyr)
library(lubridate)

# Assuming your dataframe is named "model.forecasts_ARIMA_weekly"

# Extract the year from the "yearweek" column
model.forecasts_ARIMA_weekly1 <- model.forecasts_ARIMA_weekly %>%
  mutate(year = year(yearweek))

# Print the updated dataframe with the "year" column
print(model.forecasts_ARIMA_weekly1)

```


```{r include=FALSE}
library(dplyr)
library(lubridate)

# Assuming your data frame is named "your_data_frame"

# Convert "2020 W34" to a yearweek object
desired_yearweek <- ymd("2040 W42")  # Assuming "2020 W34" corresponds to August 19, 2020 (you may need to adjust this date based on your data)

# Filter the rows where the yearweek matches the desired_yearweek
value_2045_w34 <- model.forecasts_ARIMA_weekly1 %>%
  filter(year == 2045) %>%
  pull(.mean)

# Print the result

print(unique(value_2045_w34))


```

