---
title: "Section_2"
output:
  pdf_document: default
  html_document: default
date: "2023-07-15"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



# SECTION 2 

# Report from the Point of View of the Present 

One of the very interesting features of Keeling and colleagues' research is that they were able to evaluate, and re-evaluate the data as new series of measurements were released. This permitted the evaluation of previous models' performance and a much more difficult question: If their models' predictions were "off" was this the result of a failure of the model, or a change in the system? 

## (1 point) Task 0b: Introduction 

In this introduction, you can assume that your reader will have **just** read your 1997 report. In this introduction, **very** briefly pose the question that you are evaluating, and describe what (if anything) has changed in the data generating process between 1997 and the present.

```{r}
current_directory <- getwd()
print(current_directory)

```

```{r include=FALSE}
co2_new <- read.table("co2_weekly_mlo.csv", sep = ",", header = TRUE)
co2_new

```

```{r}

install.packages("tsibble")
install.packages("fable")
install.packages("gridExtra")
install.packages("magrittr")
install.packages("ggseas")

```

# Library
```{r Library}
# Load the magrittr package
library(tidyverse)
library(tsibble)
library(fable)
library(ggplot2)
library(gridExtra)

library(magrittr)
library(dplyr)
# library(ggseas)
library(forecast)
library(tsibble)
library(stats)
library(ggseas)
library(fable)
library(fabletools)
# has_gaps(co2_new)
library(stats)
library(lubridate)
```


## (3 points) Task 1b: Create a modern data pipeline for Mona Loa CO2 data. [Weekly Data] [ EDA - ACF, PACF, Seasonality, decomposition]

The most current data is provided by the United States' National Oceanic and Atmospheric Administration, on a data page [[here](https://gml.noaa.gov/ccgg/trends/data.html)]. Gather the most recent weekly data from this page. (A group that is interested in even more data management might choose to work with the [hourly data](https://gml.noaa.gov/aftp/data/trace_gases/co2/in-situ/surface/mlo/co2_mlo_surface-insitu_1_ccgg_HourlyData.txt).) 

Create a data pipeline that starts by reading from the appropriate URL, and ends by saving an object called `co2_present` that is a suitable time series object. 

Conduct the same EDA on this data. Describe how the Keeling Curve evolved from 1997 to the present, noting where the series seems to be following similar trends to the series that you "evaluated in 1997" and where the series seems to be following different trends. This EDA can use the same, or very similar tools and views as you provided in your 1997 report. 


# Data Pipeline 

```{r}

co2_present <- read.table("co2_weekly_mlo.csv", sep = ",", header = TRUE)

co2_present <- co2_new %>%
  mutate(date = paste(year, month, day, sep = "-")) %>%
  mutate(index = as.Date(date)) %>%
  filter(year(date) >= 1997, average > 0) %>%
  as_tsibble(index = index)

co2_present

```

# EDA - Checking for non-stationary time series
** changing mean and varying variance so seem like non stationary**
```{r}
co2_new_p25 <- co2_present %>%
  ggplot(aes(x = index, y = average)) + 
  geom_line() + 
  labs(title = "checking for non-stationarity" , subtitle = "co2 level" , y = "CO2 Values" , x = "Time")

co2_new_p25
```


# Viewing the seasonality

```{r}
# Extracting Week  from the index column (which is Date)

co2_present <- co2_present %>%
  mutate(week = yearweek(index)) %>%
  as_tsibble(index = week)

co2_present
```


```{r}
co2_present <- tsibble::fill_gaps(co2_present)
```

```{r}
library(feasts)

co2_present <- tsibble::fill_gaps(co2_present)

p27 <- co2_present%>%gg_season(average , labels = "both") + 
  labs(y = "Values" , x = "Time" , title = "Seasonality")
p27
```


```{r}
library(feasts)

p27 <- co2_present%>%gg_season(average , labels = "both") + 
  labs(y = "Values" , x = "Time" , title = "Seasonality")
p27
```

** CO2 level is increasing with year and reaching 425 in 2023**


```{r}

library(feasts)
library(gridExtra)

p28 <- co2_present%>%gg_subseries (average) + 
  labs(y = "average" , x = "Time" , title = "Seasonality")

p28

grid.arrange(p27, p28, nrow = 2, ncol = 1)

```


# EDA -  checking ACF plots if they have trend or seasonality
** Gradual trend in ACF model seems like a ARIMA model and strong correlation among all lags from 1 to 12 so seems like ARIMA model ** 
```{r}
library(gridExtra)

p29 <- co2_present %>% gg_lag(average, geom = "point" , lag = 1:12) + 
  labs(title = "lagged Scatterplot" , y = "Values" , x = "index" )

p30 <- co2_present%>%ACF(average, lag_max = 48)%>%autoplot() + labs("title = CO2 levels")


grid.arrange(p29,p30, nrow = 1, ncol = 2)

```


## (1 point) Task 2b: Compare linear model forecasts against realized CO2 [Weekly Data]

Descriptively compare realized atmospheric CO2 levels to those predicted by your forecast from a linear time model in 1997 (i.e. "Task 2a"). (You do not need to run any formal tests for this task.) 


# LINEAR TREND (Modelling)

```{r}
fit_linear <- co2_present%>% model(trend_model = TSLM(average ~ trend()))

                          
```

```{r}
co2_present_linear <- subset(co2_present, select = c("average", "index"))
co2_present_linear

```

```{r}
class(co2_present_linear)
```

```{r}
# OMITTING VALUE FROM THE Null dataframe rows 

co2_present <- na.omit(co2_present)

co2_present <- co2_present %>%
  as_tsibble(index=index)
```



# QUADRATIC TREND 
```{r}

fit_quadratic <- co2_present %>%model(model_trend = TSLM(average ~ trend() + I(trend()^2 )))

```


```{r}
p38 <- augment(fit_quadratic)%>% ggplot(aes(x= index)) +
  geom_line(aes(y= average, color = "Data")) + 
  geom_line(aes(y= .fitted , color = "Fitted")) +
  labs( y = "Time" , title = "CO2 Quadratic trend in US")

p38

```


# fit linear Season

```{r}

# Monthly
co2_present_linear_season <- co2_present%>%group_by(yearmonth(index))%>%summarise(average)

co2_present_linear_season
```


```{r}

co2_present_linear_season <- co2_present_linear_season[,c("yearmonth(index)", "average")]
co2_present_linear_season
```

# (1 point) Task 3b: Compare ARIMA models forecasts against realized CO2 


```{r}
# MODEL BUILDING USINF AIC

co2_present <- tsibble::fill_gaps(co2_present)

model.aic<-co2_present %>%
  model(ARIMA(average ~ 0:1 + pdq(0:8,0:2,0:8) + PDQ(0:8,0:2,0:8), ic="aic", stepwise=F, greedy=F))

model.aic %>%
  report()
```


```{r}
# MODEL BUILDING USINF AIC adjusted

model.aicc<-co2_present %>%model(ARIMA(average ~ 0:1 + pdq(0:8,0:2,0:8) + PDQ(0:8,0:2,0:8), ic="aicc", stepwise=F, greedy=F))

model.aicc %>%
  report()

```


```{r}
# MODEL BUILDING USINF BIC adjusted

model.bic<-co2_present %>%
  model(ARIMA(average ~ 0:1 + pdq(0:8,0:2,0:8) + PDQ(0:8,0:2,0:8), ic="bic", stepwise=F, greedy=F))

model.bic %>%
  report()

```



# 4B.## (3 points) Task 4b: Evaluate the performance of 1997 linear and ARIMA models 

In 1997 you made predictions about the first time that CO2 would cross 420 ppm. How close were your models to the truth? 

After reflecting on your performance on this threshold-prediction task, continue to use the weekly data to generate a month-average series from 1997 to the present, and compare the overall forecasting performance of your models from Parts 2a and 3b over the entire period. (You should conduct formal tests for this task.) 


```{r}
co2_present <- read.table("co2_weekly_mlo.csv", sep = ",", header = TRUE)

co2_present <- co2_new %>%
  mutate(date = paste(year, month, day, sep = "-")) %>%
  mutate(index = as.Date(date)) %>%
  filter(year(date) >= 1997, average > 0) %>%
  as_tsibble(index = index)

co2_present
```

# AGREGATE DATA BY MONTH

```{r}
co2_present
```

```{r}
co2_present <- co2_present %>%
  unite(year_month, year, month, sep = "-")
```


```{r}
co2_present <- co2_present[,c("average","year_month")]
```



```{r}
# Aggregating current CO2 dataset monthly 

co2_present <- co2_present %>%
  mutate(index = year_month) 


co2_present_monthly <- co2_present %>%
  group_by(index) %>%
  summarize(average = mean(average))

co2_present_monthly
```

```{r}
co2_present_monthly <- as_tsibble(co2_present_monthly)

# Create the year-month combination as a new column
co2_present_monthly <- co2_present_monthly %>%
  mutate(yearmonth = yearmonth(index))

# Group by the year-month combination and calculate the mean of averages
co2_present_monthly <- co2_present_monthly %>%
  group_by(yearmonth) %>%
  summarize(mean_average = mean(average))

co2_present_monthly
```
```{r}
co2_present_monthly <- co2_present_monthly[c("yearmonth" ,"mean_average" )]
co2_present_monthly
```
```{r}
# Assuming your tsibble object is named "selected_data"
co2_present_monthly <- co2_present_monthly %>%
  group_by(yearmonth) %>%
  summarize(mean_average = mean(mean_average))
co2_present_monthly
```

```{r}
co2_present_monthly <- co2_present_monthly %>%
  as_tsibble(index = yearmonth)
co2_present_monthly
```
```{r}
co2_present_monthly <- co2_present_monthly %>%
  rename(index = yearmonth)

# Print the updated tsibble
print(co2_present_monthly)
```


```{r}
# OLD LINEAR MODEL 1997

# fit linear Season

co2 <- co2%>%as_tsibble()
fit_linear_season <- co2%>%model(model_trend =  TSLM(value ~ trend() + season() ))

p39 <- augment(fit_linear_season)%>%ggplot(aes(x=index)) +
  geom_line(aes(y = value , color = "Data"))  + 
  geom_line(aes(y = .fitted , color = "Fitted")) + 
  labs( y= "Time" , title = " C02 Fit linear season")
p39
```


```{r}

# OLD ARIMA MODEL 1997

# fit ARIMA Model

model.bic<-co2 %>%
  model(fable::ARIMA(value ~ 0:1 + pdq(0:8,0:2,0:8) + 
                       PDQ(0:12,0:4,0:12, period=12),
                     ic="bic", stepwise=F, greedy=F))

model.bic %>%
  report()
```


# Forecast of ARIMA model from Section 1 for the period Jan 1997 to Dec 2023
```{r}
# Forecast of ARIMA model from Section 1 for the period Jan 1997 to Dec 2023

test.size = 12*26

model.forecasts_ARIMA <-forecast(model.bic, h=test.size)
model.forecasts_ARIMA

```
```{r}
merged_df
```

# Comparision of ARIMA model prediction from Section 1 and Present CO2 values for the period Jan 1997 to Dec 2023
```{r include=FALSE}

# Comparision of ARIMA model prediction from Section 1 and Present CO2 values for the period Jan 1997 to Dec 2023

library(dplyr)

# Assuming model.forecasts and co2_present_monthly are your data frames

# Merge the two data frames on the 'index' column, and handle missing values with 0
merged_df <- merge(model.forecasts_ARIMA, co2_present_monthly, by = "index", all.x = TRUE)
merged_df[is.na(merged_df)] <- 0  # Replace missing values with 0

# Select the desired columns and rename them if needed
selected_df <- merged_df %>%
  select(index, .mean, mean_average) %>%
  rename(predicted = .mean, current_value = mean_average)

# Print the result
print(selected_df)




```

#After comparision, Evaluate performance of ARIMA MODEL from Section 1 on the Present CO2 Dataset for the period Jan 1997 to Dec 2023
```{r}

# After comparision, Evaluate performance of ARIMA MODEL from Section 1 on the Present CO2 Dataset for the period Jan 1997 to Dec 2023

selected_df$diff_squared <- (selected_df$predicted - selected_df$current_value)^2

# Calculate the RMSE
rmse <- sqrt(mean(selected_df$diff_squared))

# Print the RMSE
print(paste("Root Mean Squared Error (RMSE):", rmse))

```

# Forecast of LINEAR model from Section 1 for the period Jan 1997 to Dec 2023
```{r}

#  Forecast of LINEAR model from Section 1 for the period Jan 1997 to Dec 2023

test.size = 12*26

model.forecasts_linear <-forecast(fit_linear_season, h=test.size)
model.forecasts_linear 
```
```{r}
merged_df_linear
```


# Comparision of LINEAR model prediction from Section 1 for the period Jan 1997 to Dec 2023 and Present CO2 values for the period Jan 1997 to Dec 2023
```{r include=FALSE}

# Comparision of LINEAR model prediction from Section 1 for the period Jan 1997 to Dec 2023 and Present CO2 values for the period Jan 1997 to Dec 2023

library(dplyr)

# Assuming model.forecasts and co2_present_monthly are your data frames

# Merge the two data frames on the 'index' column, and handle missing values with 0
merged_df_linear  <- merge(model.forecasts_linear , co2_present_monthly, by = "index", all.x = TRUE)
merged_df_linear[is.na(merged_df)] <- 0  # Replace missing values with 0

# Select the desired columns and rename them if needed
selected_df_linear  <- merged_df_linear %>%
  select(index, .mean, mean_average) %>%
  rename(predicted = .mean, current_value = mean_average)

# Print the result
print(selected_df_linear)
```


```{r}
merged_df_linear
```


#After comparision, Evaluate performance of LINEAR MODEL from Section 1 on the Present CO2 Dataset for the period Jan 1997 to Dec 2023
```{r}

# After comparision, Evaluate performance of LINEAR MODEL from Section 1 on the Present CO2 Dataset for the period Jan 1997 to Dec 2023

# Remove rows with missing values in 'predicted' or 'current_value'
selected_df_linear <- selected_df_linear[complete.cases(selected_df_linear[c('predicted', 'current_value')]), ]

# Calculate the squared differences between 'predicted' and 'current_value'
selected_df_linear$diff_squared <- (selected_df_linear$predicted - selected_df_linear$current_value)^2

# Calculate the RMSE
rmse <- sqrt(mean(selected_df_linear$diff_squared))

# Print the RMSE
print(paste("Root Mean Squared Error (RMSE):", rmse))

```




## (4 points) Task 5b: Train best models on present data

Seasonally adjust the weekly NOAA data, and split both seasonally-adjusted (SA) and non-seasonally-adjusted (NSA) series into training and test sets, using the last two years of observations as the test sets. For both SA and NSA series, fit ARIMA models using all appropriate steps. Measure and discuss how your models perform in-sample and (psuedo-) out-of-sample, comparing candidate models and explaining your choice. In addition, fit a polynomial time-trend model to the seasonally-adjusted series and compare its performance to that of your ARIMA model.

# Seasonally adjusted data by Smoothing - To have a clearer view of the trend, we can remove the seasonal movement by aggregating the data to the annual level.


** from the graph it appears that there is a good upward trend agregating the seasons**

```{r}

# CO2 presents extration for period > 1997 and average > 0

co2_present <- read.table("co2_weekly_mlo.csv", sep = ",", header = TRUE)

co2_present <- co2_present %>%
  mutate(date = paste(year, month, day, sep = "-")) %>%
  mutate(index = as.Date(date)) %>%
  filter(year(date) >= 1997, average > 0) %>%
  as_tsibble(index = index)

co2_present
```


```{r}
co2_present_yearly <- co2_present[c("year", "average")]
co2_present_yearly
```


```{r}
# Aggregated data Yearly 

co2_present_yearly_aggregate <- co2_present_yearly %>%
  #mutate(year = year(index))%>%
  group_by(year) %>%
  summarize(average = mean(average))

# Print the result
print(co2_present_yearly_aggregate)
```


```{r}
library(dplyr)
library(lubridate)

p26 <- co2_present %>%
  mutate(year = year(index)) %>%
  group_by(year) %>%
  summarise(avg_total = sum(average)) %>%
  ggplot(aes(x = year, y = avg_total)) +
  geom_line() + 
  labs(title = "Aggregating by year", y = "Values", x = "Time")

p26


```

```{r}
co2_present_yearly_aggregate
```

```{r}
# CO2 data yearly aggregated

co2_present_yearly_aggregate <- co2_present_yearly_aggregate %>%
  arrange(desc(year))

# Extract the last two years for the test dataset
test_data <- co2_present_yearly_aggregate %>%
  slice(1:2)

# Extract the remaining data for the training dataset
train_data <- co2_present_yearly_aggregate %>%
  slice(-(1:2))

# Print the test and train datasets
print("Test Data:")
print(test_data)

print("Training Data:")
print(train_data)
```

# ARIMA model development on training dataset for the period Jan 1997 to Dec 2021

```{r}

# ARIMA model development on training dataset for the period Jan 1997 to Dec 2021

library("fabletools")

train_data <- train_data%>%as_tsibble(index = year)

model.bic_yearly <-train_data %>%
  model(fable::ARIMA(average ~ 0:1 + pdq(0:8,0:2,0:8) + 
                       PDQ(0:12,0:4,0:12, period=12),
                     ic="bic", stepwise=F, greedy=F))

model.bic_yearly %>%
  report()
```

# Forecasts of Section 2 ARIMA model on Train Dataset [Jan 2022 to Dec 2023]
```{r}
# Forecasts of Section 2 ARIMA model on Train Dataset [Jan 2022 to Dec 2023]

test.size = 2

model.forecasts_ARIMA_yearly <-forecast(model.bic_yearly, h=test.size)
model.forecasts_ARIMA_yearly

```

```{r}
test_data
```

# Comparision of the ARIMA model prediction made in Section 2 for the period Jan 2022 to Dec 2023 with the Present actual CO2 values observed for the period Jan 2022 to Dec 2023
```{r}

# Comparision of the ARIMA model prediction made in Section 2 for the period Jan 2022 to Dec 2023 with the Present actual CO2 values observed for the period Jan 2022 to Dec 2023

library(dplyr)

# Assuming model.forecasts and co2_present_monthly are your data frames

# Merge the two data frames on the 'index' column, and handle missing values with 0
merged_df_yearly <- merge(model.forecasts_ARIMA_yearly, test_data, by = "year", all.x = TRUE)
# merged_df_yearly[is.na(merged_df)] <- 0  # Replace missing values with 0

# Select the desired columns and rename them if needed
selected_df_yearly <- merged_df_yearly %>%
  select(year, average.y , .mean) %>%
  rename(predicted = .mean, current_value = average.y)

# Print the result
print(selected_df_yearly)
```

#After comparision, Evaluate performance of ARIMA MODEL from Section 2 on the Present CO2 Dataset for the period Jan 2022 to Dec 2023
```{r}
# #After comparision, Evaluate performance of ARIMA MODEL from Section 2 on the Present CO2 Dataset for the period Jan 2022 to Dec 2023

# Remove rows with missing values in 'predicted' or 'current_value'
# selected_df_linear <- selected_df_linear[complete.cases(selected_df_linear[c('predicted', 'current_value')]), ]

# Calculate the squared differences between 'predicted' and 'current_value'
selected_df_yearly$diff_squared <- (selected_df_yearly$predicted - selected_df_yearly$current_value)^2

# Calculate the RMSE
rmse_yearly <- sqrt(mean(selected_df_yearly$diff_squared))

# Print the RMSE
print(paste("Root Mean Squared Error (RMSE):", rmse_yearly))

```

```{r}
train_data
```

# LINEAR model development on Training dataset for the period Jan 1997 to Dec 2021

```{r}
# LINEAR model development on Training dataset for the period Jan 1997 to Dec 2021

train_data <- train_data%>%as_tsibble()
fit_linear_season_yeary <- train_data%>%model(model_trend =  TSLM(average ~ trend() + season() ))

p39 <- augment(fit_linear_season_yeary)%>%ggplot(aes(x=year)) +
  geom_line(aes(y = average , color = "Data"))  + 
  geom_line(aes(y = .fitted , color = "Fitted")) + 
  labs( y= "Time" , title = " C02 Fit linear season")
p39

```

# Forecasts of Section 2 LINEAR model on Test Dataset [Jan 2022 to Dec 2023]
```{r}
# Forecasts of Section 2 LINEAR model on Test Dataset [Jan 2022 to Dec 2023]

test.size = 2

model.forecasts_linear_yearly <-forecast(fit_linear_season_yeary, h=test.size)
model.forecasts_linear_yearly  
```

```{r}
co2_present_monthly
```


# Comparision of the LINEAR model prediction made in Section 2 for the period Jan 2022 to Dec 2023 with the Present actual CO2 values observed for the period Jan 2022 to Dec 2023
```{r}
# Merging Predictions from ARIMA Model and Current Values

library(dplyr)

# Assuming model.forecasts and co2_present_monthly are your data frames

# Merge the two data frames on the 'index' column, and handle missing values with 0
merged_df_yearly_linear <- merge(model.forecasts_linear_yearly, test_data, by = "year", all.x = TRUE)
# merged_df_yearly[is.na(merged_df)] <- 0  # Replace missing values with 0

# Select the desired columns and rename them if needed
selected_df_yearly_linear <- merged_df_yearly_linear %>%
  select(year, average.y , .mean) %>%
  rename(predicted = .mean, current_value = average.y)

# Print the result
print(selected_df_yearly_linear)
```

#After comparision, Evaluate performance of LINEAR MODEL from Section 2 on the Present CO2 Dataset for the period Jan 2022 to Dec 2023
```{r}
# #After comparision, Evaluate performance of ARIMA MODEL from Section 2 on the Present CO2 Dataset for the period Jan 2022 to Dec 2023

# Remove rows with missing values in 'predicted' or 'current_value'
# selected_df_linear <- selected_df_linear[complete.cases(selected_df_linear[c('predicted', 'current_value')]), ]

# Calculate the squared differences between 'predicted' and 'current_value'
selected_df_yearly_linear$diff_squared <- (selected_df_yearly_linear$predicted - selected_df_yearly_linear$current_value)^2

# Calculate the RMSE
rmse_yearly <- sqrt(mean(selected_df_yearly_linear$diff_squared))

# Print the RMSE
print(paste("Root Mean Squared Error (RMSE):", rmse_yearly))

```


## Transitioning to Analysis of Seasonally Adjusted data through STL 

```{r}
# CO2 presents extration for period > 1997 and average > 0

co2_present <- read.table("co2_weekly_mlo.csv", sep = ",", header = TRUE)

co2_present <- co2_present %>%
  mutate(date = paste(year, month, day, sep = "-")) %>%
  mutate(index = as.Date(date)) %>%
  filter(year(date) >= 1997, average > 0) %>%
  as_tsibble(index = index)

co2_present
```

```{r}
co2_present_reduced <- co2_present%>%select(average , index)
co2_present_reduced
```

```{r}
# IMPORTANT CODE 
library(tsibble)
library(dplyr)
library(stats)
library(lubridate)

co2_present_reduced1 <- as_tsibble(co2_present_reduced)

# Create the year-month combination as a new column
co2_present_reduced2 <- co2_present_reduced1 %>%
  mutate(yearmonth = yearmonth(index))

# Group by the year-month combination and calculate the mean of averages
co2_present_yearlymonthly <- co2_present_reduced2 %>%
  group_by(yearmonth) %>%
  summarize(mean_average = mean(average))

co2_present_yearlymonthly
```


```{r}
# library(dplyr)

# Assuming the tsibble object is called "tsibble_data"

# Selecting the columns "yearmonth" and "mean_average"
# selected_data <- co2_present_yearlymonthly %>%
#   select(yearmonth, mean_average)
# selected_data
```

```{r}
# Extracted certain columns but getting Tibble object 

selected_data2 <- co2_present_yearlymonthly[c("yearmonth" ,"mean_average" )]
selected_data2
```

```{r}
# Aggregating Tibble object by Yearmonth

library(dplyr)

# Assuming your tsibble object is named "selected_data"
grouped_data <- selected_data2 %>%
  group_by(yearmonth) %>%
  summarize(mean_average = mean(mean_average))
grouped_data
```

```{r}
# Converting Tibble to Tsibble

library(tsibble)

# Assuming your tibble is named "your_tibble"
tsbl_data <- grouped_data %>%
  as_tsibble(index = yearmonth)
tsbl_data
```


#### SEASONALLY ADJUSTED Dataset through STL for the period Jan 1997 to Dec 2021
```{r}
# DECOMPOSING TIME SERIES

library(feasts)
library(fabletools)

dcmp_add <- tsbl_data %>%
  model(stl = STL(mean_average))

dcmp_multi <- tsbl_data %>%
  model(stl = STL(mean_average))
```


```{r}
# library(dplyr)
# library(gridExtra)

# p31 <- components(dcmp_add) %>%
#  as_tsibble() %>%
#  autoplot(average, colour="gray") +
#  geom_line(aes(y=trend), colour = "#D55E00") +

#  labs(y = "Value", x="Index",
#    title = "CO2 Levels")

# p32 <- components(dcmp_multi) %>%
#  as_tsibble() %>%
#  autoplot(average, colour="gray") +
#  geom_line(aes(y=value), colour = "#D55E00") +
#  labs(y = "Value", x="Index",
#    title = "log of CO2 Levels")

# grid.arrange(p31,p32, nrow = 1, ncol =2)

```

# Extracting the Trend, Seasonal, and Remainder components from the dataset after applying seasonal adjustment through STL for the period Jan 1997 to Dec 2021
```{r}

library(fable)
library(fabletools)
library(ggplot2)
library(gridExtra)

p33 <- components(dcmp_add) %>% autoplot()

p34<- components(dcmp_add)%>%
  ACF(remainder) %>%
  autoplot() + labs(title="Residuals additive decomposition")

p35 <- components(dcmp_multi) %>% autoplot()

p36<- components(dcmp_multi)%>%
  ACF(remainder) %>%
  autoplot() + labs(title="Residuals of multiplicative decomposition")

grid.arrange(p33,p34,p35 ,p36, nrow = 2, ncol = 2)

```

```{r}
p31_1 <- components(dcmp_add) %>%
   as_tsibble() 

p31_1

```

```{r}
seasonally_adjusted_STL <- p31_1%>%select(yearmonth , season_adjust)
seasonally_adjusted_STL
```

```{r}

#seasonally_adjusted_STL[nrow(seasonally_adjusted_STL - 24): nrow(seasonally_adjusted_STL),]
rows <- nrow(seasonally_adjusted_STL)
test_data <- seasonally_adjusted_STL[(rows-24): rows,]
train_data <- seasonally_adjusted_STL[0: (rows-24),]
```

```{r}
train_data
```
```{r}
test_data
```



## Using Seasonally Adjusted data through STL for ARIMA

# ARIMA model development on training dataset for the period Jan 1997 to Dec 2021

```{r}

# ARIMA model development on training dataset for the period Jan 1997 to Dec 2021

library("fabletools")

train_data <- train_data%>%as_tsibble(index = yearmonth)

model.bic_monthlyyearly <-train_data %>%
  model(fable::ARIMA(season_adjust ~ 0:1 + pdq(0:8,0:2,0:8) + 
                       PDQ(0:12,0:4,0:12, period=12),
                     ic="bic", stepwise=F, greedy=F))

model.bic_monthlyyearly %>%
  report()
```

# Forecasts of Section 2 ARIMA model on Train Dataset [Jan 2022 to Dec 2023]
```{r}
# Forecasts of Section 2 ARIMA model on Train Dataset [Jan 2022 to Dec 2023]

test.size = 2

model.forecasts_ARIMA_yearly <-forecast(model.bic_monthlyyearly, h=test.size)
model.forecasts_ARIMA_yearly

```

```{r}
test_data
```

# Comparision of the ARIMA model prediction made in Section 2 for the period Jan 2022 to Dec 2023 with the Present actual CO2 values observed for the period Jan 2022 to Dec 2023
```{r}

# Comparision of the ARIMA model prediction made in Section 2 for the period Jan 2022 to Dec 2023 with the Present actual CO2 values observed for the period Jan 2022 to Dec 2023

library(dplyr)

# Assuming model.forecasts and co2_present_monthly are your data frames

# Merge the two data frames on the 'index' column, and handle missing values with 0
merged_df_yearly <- merge(model.forecasts_ARIMA_yearly, test_data, by = "yearmonth", all.x = TRUE)
# merged_df_yearly[is.na(merged_df)] <- 0  # Replace missing values with 0

# Select the desired columns and rename them if needed
selected_df_yearly <- merged_df_yearly %>%
  select(yearmonth, season_adjust.y , .mean) %>%
  rename(predicted = .mean, current_value = season_adjust.y)

# Print the result
print(selected_df_yearly)
```

#After comparision, Evaluate performance of ARIMA MODEL from Section 2 on the Present CO2 Dataset for the period Jan 2022 to Dec 2023
```{r}
# #After comparision, Evaluate performance of ARIMA MODEL from Section 2 on the Present CO2 Dataset for the period Jan 2022 to Dec 2023

# Remove rows with missing values in 'predicted' or 'current_value'
# selected_df_linear <- selected_df_linear[complete.cases(selected_df_linear[c('predicted', 'current_value')]), ]

# Calculate the squared differences between 'predicted' and 'current_value'
selected_df_yearly$diff_squared <- (selected_df_yearly$predicted - selected_df_yearly$current_value)^2

# Calculate the RMSE
rmse_yearly <- sqrt(mean(selected_df_yearly$diff_squared))

# Print the RMSE
print(paste("Root Mean Squared Error (RMSE):", rmse_yearly))

```


```{r}
train_data
```



## Using Seasonally Adjusted data through STL for LINEAR
# LINEAR model development on Training dataset for the period Jan 1997 to Dec 2021

```{r}
# LINEAR model development on Training dataset for the period Jan 1997 to Dec 2021

train_data <- train_data%>%as_tsibble()
fit_linear_season_yeary <- train_data%>%model(model_trend =  TSLM(season_adjust ~ trend() + season() ))

p39 <- augment(fit_linear_season_yeary)%>%ggplot(aes(x=yearmonth)) +
  geom_line(aes(y = season_adjust , color = "Data"))  + 
  geom_line(aes(y = .fitted , color = "Fitted")) + 
  labs( y= "Time" , title = " C02 Fit linear season")
p39

```

# Forecasts of Section 2 LINEAR model on Test Dataset [Jan 2022 to Dec 2023]
```{r}
# Forecasts of Section 2 LINEAR model on Test Dataset [Jan 2022 to Dec 2023]

test.size = 2

model.forecasts_linear_yearly <-forecast(fit_linear_season_yeary, h=test.size)
model.forecasts_linear_yearly  
```

# Comparision of the LINEAR model prediction made in Section 2 for the period Jan 2022 to Dec 2023 with the Present actual CO2 values observed for the period Jan 2022 to Dec 2023
```{r}
# Merging Predictions from ARIMA Model and Current Values

library(dplyr)

# Assuming model.forecasts and co2_present_monthly are your data frames

# Merge the two data frames on the 'index' column, and handle missing values with 0
merged_df_yearly_linear <- merge(model.forecasts_linear_yearly, test_data, by = "yearmonth", all.x = TRUE)
# merged_df_yearly[is.na(merged_df)] <- 0  # Replace missing values with 0

# Select the desired columns and rename them if needed
selected_df_yearly_linear <- merged_df_yearly_linear %>%
  select(yearmonth, season_adjust.y , .mean) %>%
  rename(predicted = .mean, current_value = season_adjust.y)

# Print the result
print(selected_df_yearly_linear)
```

#After comparision, Evaluate performance of LINEAR MODEL from Section 2 on the Present CO2 Dataset for the period Jan 2022 to Dec 2023
```{r}
# #After comparision, Evaluate performance of ARIMA MODEL from Section 2 on the Present CO2 Dataset for the period Jan 2022 to Dec 2023

# Remove rows with missing values in 'predicted' or 'current_value'
# selected_df_linear <- selected_df_linear[complete.cases(selected_df_linear[c('predicted', 'current_value')]), ]

# Calculate the squared differences between 'predicted' and 'current_value'
selected_df_yearly_linear$diff_squared <- (selected_df_yearly_linear$predicted - selected_df_yearly_linear$current_value)^2

# Calculate the RMSE
rmse_yearly <- sqrt(mean(selected_df_yearly_linear$diff_squared))

# Print the RMSE
print(paste("Root Mean Squared Error (RMSE):", rmse_yearly))

```

## ** The RMSE of the linear model is 1.567, but the RMSE of the ARIMA model is 0.11932, which is smaller. Therefore, the ARIMA model is a better model**


### Non-seasonally Adjusted Dataset

```{r}
# CO2 presents extration for period > 1997 and average > 0

co2_present <- read.table("co2_weekly_mlo.csv", sep = ",", header = TRUE)

co2_present <- co2_present %>%
  mutate(date = paste(year, month, day, sep = "-")) %>%
  mutate(index = as.Date(date)) %>%
  filter(year(date) >= 1997, average > 0) %>%
  as_tsibble(index = index)

co2_present
```

```{r}
co2_present_reduced_weekly <- co2_present[c("average" ,"index")]
co2_present_reduced_weekly

```

```{r}
co2_present_reduced_weekly <- co2_present_reduced_weekly %>%
  mutate(yearweek = yearweek(index))
co2_present_reduced_weekly
```

```{r}
# Assuming your tsibble object is named "selected_data"
co2_present_reduced_weekly_group <- co2_present_reduced_weekly %>%
  group_by(yearweek) %>%
  summarize(mean_average = mean(average))
co2_present_reduced_weekly_group
```

```{r}
co2_present_reduced_weekly_group <- co2_present_reduced_weekly_group[c("yearweek" , "mean_average")]
co2_present_reduced_weekly_group

```


```{r}
library(tsibble)

# Assuming your tibble is named "your_tibble"
co2_present_reduced_weekly_group <- co2_present_reduced_weekly_group %>%
  as_tsibble(index = yearweek)
co2_present_reduced_weekly_group
```

```{r}

co2_present_reduced_weekly_group <- co2_present_reduced_weekly_group %>%
  as_tsibble(index=yearweek)
co2_present_reduced_weekly_group

```


```{r}
# CO2 data Split into Train and Test Non-Seasonally Adjusted Dataset 

co2_present_reduced_weekly_group <- co2_present_reduced_weekly_group %>%
  arrange(desc(yearweek))

# Extract the last two years for the test dataset
test_data <- co2_present_reduced_weekly_group %>%
  slice(1:96)

# Extract the remaining data for the training dataset
train_data <- co2_present_reduced_weekly_group %>%
  slice(-(1:96))

# Print the train datasets
print("Training Data:")
print(train_data)

# Print the test 
print("Test Data:")
print(test_data)

```


# ARIMA model development on Non-Seasonally Adjusted training dataset for the period Jan 1997 to Dec 2021
```{r}

# ARIMA model development on Non-seasonally adjusted training dataset for the period Jan 1997 to Dec 2021
library("fabletools")

# Filling gaps
train_data <- tsibble::fill_gaps(train_data)

# Developing model from non-seasonal adjusted dataset
model.bic_weekly <-train_data %>%
  model(fable::ARIMA(mean_average ~ 0:1 + pdq(0:8,0:2,0:8) + 
                       PDQ(0:12,0:4,0:12, period=12),
                     ic="bic", stepwise=F, greedy=F))

 model.bic_weekly %>%
  report()
```

# Forecasts of Section 2 ARIMA model on Non-Seasonally Adjusted Train Dataset [Jan 2022 to Dec 2023]
```{r}
# Forecasts of Section 2 ARIMA model on Non-seasonally adjusted Train Dataset [Jan 2022 to Dec 2023]

test.size = 96

model.forecasts_ARIMA_weekly <-forecast(model.bic_weekly, h=test.size)
model.forecasts_ARIMA_weekly

```

# Comparision of the ARIMA model prediction made in Section 2 for the period Jan 2022 to Dec 2023 with the Present actual CO2 values observed for the period Jan 2022 to Dec 2023
```{r}

# Comparision of the ARIMA model prediction made in Section 2 for the period Jan 2022 to Dec 2023 with the Present actual CO2 values observed for the period Jan 2022 to Dec 2023

library(dplyr)

# Assuming model.forecasts and co2_present_monthly are your data frames

# Merge the two data frames on the 'index' column, and handle missing values with 0
merged_df_weekly <- merge(model.forecasts_ARIMA_weekly, test_data, by = "yearweek", all.x = TRUE)
# merged_df_yearly[is.na(merged_df)] <- 0  # Replace missing values with 0

# Select the desired columns and rename them if needed
selected_df_weekly <- merged_df_weekly %>%
  select(yearweek, mean_average.y , .mean) %>%
  rename(predicted = .mean, current_value = mean_average.y)

# Print the result
print(selected_df_weekly)
```

#After comparision, Evaluate performance of ARIMA MODEL from Section 2 on the Present CO2 Dataset for the period Jan 2022 to Dec 2023
```{r}
# #After comparision, Evaluate performance of ARIMA MODEL from Section 2 on the Present CO2 Dataset for the period Jan 2022 to Dec 2023

# Remove rows with missing values in 'predicted' or 'current_value'
# selected_df_linear <- selected_df_linear[complete.cases(selected_df_linear[c('predicted', 'current_value')]), ]

# Calculate the squared differences between 'predicted' and 'current_value'
selected_df_weekly$diff_squared <- (selected_df_weekly$predicted - selected_df_weekly$current_value)^2

# Calculate the RMSE
rmse_yearly <- sqrt(mean(selected_df_yearly$diff_squared))

# Print the RMSE
print(paste("Root Mean Squared Error (RMSE):", rmse_yearly))

```

## Using NON- Seasonally Adjusted data for LINEAR
# LINEAR model development on NON- Seasonally Adjusted Training dataset for the period Jan 1997 to Dec 2021

```{r}
# LINEAR model development on NON- Seasonally Adjusted Training dataset for the period Jan 1997 to Dec 2021

train_data <- train_data%>%as_tsibble()
fit_linear_NON_season_weekly <- train_data%>%model(model_trend =  TSLM(mean_average ~ trend() + season() ))

p39 <- augment(fit_linear_NON_season_weekly)%>%ggplot(aes(x=yearweek)) +
  geom_line(aes(y = mean_average , color = "Data"))  + 
  geom_line(aes(y = .fitted , color = "Fitted")) + 
  labs( y= "Time" , title = " C02 Fit linear season")
p39

```

# Forecasts of Section 2 LINEAR model on NON- Seasonally Adjusted Test Dataset [Jan 2022 to Dec 2023]
```{r}
# Forecasts of Section 2 LINEAR model on NON- Seasonally Adjusted Test Dataset [Jan 2022 to Dec 2023]

test.size = 96

model.forecasts_weekly_non_seasonal <-forecast(fit_linear_NON_season_weekly, h=test.size)
model.forecasts_weekly_non_seasonal  
```

# Comparision of the LINEAR model prediction made in Section 2 NON- Seasonally Adjusted for the period Jan 2022 to Dec 2023 with the Present actual CO2 values observed for the period Jan 2022 to Dec 2023
```{r}
# Merging Predictions from ARIMA Model and Current Values for NON- Seasonally Adjusted Dataset

library(dplyr)

# Assuming model.forecasts and co2_present_monthly are your data frames

# Merge the two data frames on the 'index' column, and handle missing values with 0
merged_df_weekly_non_seasonal <- merge(model.forecasts_weekly_non_seasonal, test_data, by = "yearweek", all.x = TRUE)
# merged_df_yearly[is.na(merged_df)] <- 0  # Replace missing values with 0

# Select the desired columns and rename them if needed
selected_weekly_non_seasonal <- merged_df_weekly_non_seasonal %>%
  select(yearweek, mean_average.y , .mean) %>%
  rename(predicted = .mean, current_value = mean_average.y)

# Print the result
print(selected_weekly_non_seasonal)
```

#After comparision, Evaluate performance of LINEAR MODEL from Section 2 on the Present CO2 NON- Seasonally Adjusted Dataset for the period Jan 2022 to Dec 2023
```{r}
# #After comparision, Evaluate performance of ARIMA MODEL from Section 2 on the Present CO2 Dataset for the period Jan 2022 to Dec 2023

# Remove rows with missing values in 'predicted' or 'current_value'
# selected_df_linear <- selected_df_linear[complete.cases(selected_df_linear[c('predicted', 'current_value')]), ]

# Calculate the squared differences between 'predicted' and 'current_value'
selected_weekly_non_seasonal$diff_squared <- (selected_weekly_non_seasonal$predicted - selected_weekly_non_seasonal$current_value)^2

# Calculate the RMSE
rmse_weekly_non_seasonal <- sqrt(mean(selected_weekly_non_seasonal$diff_squared))

# Print the RMSE
print(paste("Root Mean Squared Error (RMSE):", rmse_weekly_non_seasonal))

```

## ** The RMSE of the linear model is 1.78, but the RMSE of the ARIMA model is 0.11932, which is smaller. Therefore, the ARIMA model is a better model**







## (3 points) Task Part 6b: How bad could it get?

With the non-seasonally adjusted data series, generate predictions for when atmospheric CO2 is expected to be at 420 ppm and 500 ppm levels for the first and final times (consider prediction intervals as well as point estimates in your answer). Generate a prediction for atmospheric CO2 levels in the year 2122. How confident are you that these will be accurate predictions?

```{r}
test.size = 12784 # weekly time series unit

model.forecasts_ARIMA_weekly <-forecast(model.bic_weekly, h=test.size)
model.forecasts_ARIMA_weekly
```


```{r}
# Forecasts of Section2 ARIMA model for the period [Jan 2022 to Dec 2122]

test.size = 12784 # weekly time series unit

model.forecasts_ARIMA_weekly <-forecast(model.bic_weekly, h=test.size)
model.forecasts_ARIMA_weekly
```

# predicted co2 value 420 

```{r}
# Whether 420ppm CO2 present in data or not?
# period for [Jan 2022 to Dec 2122]

library(dplyr)

# Assuming your model.forecasts_ARIMA_weekly contains the columns 'date' and '.mean'

# Check if there is any value near 420 (within a range of +/- 10) in the .mean column
value_420ppm <- any(abs(model.forecasts_ARIMA_weekly$.mean - 420) <= 10)

# Print the result
print(value_420ppm)

```
**420 ppm CO2 level is not present in the forecasted data until the year 2122. Hence upper and lower bound doesnt exist either.**

# predicted co2 value 500 
```{r}

# Whether 500ppm CO2 present in data or not?
# period for [Jan 2022 to Dec 2122]

library(dplyr)

# Assuming your model.forecasts_ARIMA_weekly contains the columns 'date' and '.mean'

# Check if there is any value near 420 (within a range of +/- 10) in the .mean column
value_500ppm <- any(abs(model.forecasts_ARIMA_weekly$.mean - 500) <= 10)

# Print the result
print(value_500ppm)

```
**500 ppm CO2 level is not present in the forecasted data until the year 2122.Hence upper and lower bound doesnt exist either.**

# ## Confidence interval

Generate a prediction for atmospheric CO2 levels in the year 2100. How confident are you that these will be accurate predictions?

```{r}

model.forecasts_ARIMA_weekly_confidence_interval <-model.forecasts_ARIMA_weekly %>% mutate(upper=quantile(.mean,0.95),lower=quantile(.mean,0.05))
model.forecasts_ARIMA_weekly_confidence_interval

```

```{r}
library(dplyr)
library(lubridate)

# Assuming your dataframe is named "model.forecasts_ARIMA_weekly"

# Extract the year from the "yearweek" column
model.forecasts_ARIMA_weekly1 <- model.forecasts_ARIMA_weekly %>%
  mutate(year = year(yearweek))

# Print the updated dataframe with the "year" column
print(model.forecasts_ARIMA_weekly1)

```


```{r}
library(dplyr)
library(lubridate)

# Assuming your data frame is named "your_data_frame"

# Convert "2020 W34" to a yearweek object
desired_yearweek <- ymd("2040 W42")  # Assuming "2020 W34" corresponds to August 19, 2020 (you may need to adjust this date based on your data)

# Filter the rows where the yearweek matches the desired_yearweek
value_2045_w34 <- model.forecasts_ARIMA_weekly1 %>%
  filter(year == 2045) %>%
  pull(.mean)

# Print the result

print(unique(value_2045_w34))


```

